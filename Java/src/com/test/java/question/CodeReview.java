package com.test.java.question;

import java.io.File;

public class CodeReview {

	public static void main(String[] args) {
		

//		datetime ]===============================================================================
//		1.	HOUR_OF_DAY(24H) 
//			HOUR(12H) > 0 ~ 11 > 12시일때 12가 아닌 0으로 표현됨
		
//		4.	월(month)을 입력받을 때 > month는 0~11 > -1 (***)
		
//		5. 	아빠와 딸의 생년월일을 입력받고 며칠을 더 살았는지 계산 > 아빠Tick - 딸TIck(X) > 딸Tick - 아빠Tick(O)

		
//		conditional-if]========================================================================== 
//		3. 	입력받은 하나의 문자를 char로 형변환하여 유효성 검사 > 입력받은 문자가 두 문자이면 유효성 검사가 안됨
		
//		5. 	if문으로 연산자에 따라 나눴다면 > 연산자를 %c로 할 필요 없이 +, -, *, /, %로 바로 표현

//		7. 	입력하는 숫사의 개수가 정해져 있다면 > 홀수의 갯수 = 총 갯수 - 짝수의 갯수

//		8. 	총 주차시간(분) > 시각 - 시각 > 계산해야 하는 결과값이 하루 내의 시간!! > 0시 0분을 기준으로 '분'으로 변환 
//			int parkingMin = (exitHour - entryHour) * 60 + (exitMin - entryMin);
//			=> int parkingMin = (exitHour * 60 + exitMin) - (entryHour * 60 + entryMin);
		
		
//		iteration-for]=========================================================================== 
		
//		6.	(1) 잘못 풀었음 (***)(***) > for문을 쓸 때 루프변수에 주의하기
//				- for(int i=startNum; i<=endNum; i++) {} //startNum 입력한 시작숫자 endNum 입력한 종료숫자
//				- for문에서 루프변수(i)가 직접 사용되면, 루프변수의 의미가 몇번째 인지를 나타내는지 혹은 특정 값을 나타내는지를 주의!!!(***) 
//		
//			(2) 1 - 2 + 3 - 4 + 5 = 3를 출력할 때, 의미단위로 묶으면 좋음 
//				(1 - ) (2 + ) (3 - ) (4 + ) (5 = 3) > 코드가 짧아짐
//			=> 	(1) (- 2) (+ 3) (- 4) (+ 5) (= 3) > 출력부호와 실제 덧셈뺄셈이 일치해서 의미파악이 쉬움
//		
//			(3) 출력을 할 때
//				방법1: int order=1;을 선언하고 for문 안에서 order++;를 하면서 홀수번째 짝수번째인지로 판단하기 
//				방법2: int sign=1;을 선언하고 for문 안에서 sign*=(-1);을 하면서 부호가 +인지 -인지로 판단하기
		
//		8. 	(1) 잘못 풀었음 (***)(***) 
//				- (o) 서기 1년 1월 1일부터 서기 2022년 1월 1일까지는 며칠인지는 잘 구함
//				- (x) 2022년 1월 1일부터 2022년 3월 17일까지 며칠인지 구할 때 윤년을 고려하지 않음		
			
//			(2) 윤년인지를 구할 때, 4년마다 1년을 더하고, 100년마다 1년을 빼고, 400년마다 1년을 더한다.
//				((year % 4 == 0) && (year % 100 == 0) && (year % 400 == 0)) 
//			=> 	(year % 400 == 0) 
//			
//			(3) Ex22_for > m13()
		
//		9. 변수명만 봐도 의미를 알 수 있도록!!
//			(input == num)  //사용자가 입력한 숫자 == 컴퓨터가 생각한 숫자
//		   	=> (userNum == ComNum) 
		
//		iteration-while] Q11~Q14 ================================================================
		
//		10. (1) 원하는 만큼 입력받은 값을 마지막에 출력하려면 String 변수를 선언하고 문자열 누적! ***
//		
//			(2) for(loop) { if(sum >= 100) {loop = false}}  (x)
//			=> 	for(sum < 100) {} (o)

		
//		iteration-다중for] Q15~Q26 ===============================================================
		
//		19. 2중for문 2개에서 안쪽for문의 식만 규칙적으로 다를 때 -> 3중for문 1개로 표현 가능
		
//		22.	(1) "\b"는 삭제가 아니라 커서를 한 문자 앞으로!!!! (***) 	
			
//			(2) 공약수를 구할 때, 작은 수와 큰 수를 구분할 필요가 없음 (***) -> 불필요한 코드 삭제
		
//		26. 1 + 1 + 2 + 3 + 5 + .. + 89 = 232 를 계산할 때
//			(n1) + (n2) + (n1 += n2) + (n2 += n1) (x) 	//복잡하게 느껴지는 구조
//			=> n2 + n2 + n2 + n2 (o)  					//n1=0, n2=1 -> temp = n1+n2; n1=n2; n2=temp;
		
//		array]======================================================================================
		
//		9.
		
//		16. 처음에 초기화로 " "를 지정해주고 나중에 "■"로 덮어 쓸 수 있음.
//		17. 
//		18.
//		19.
		
//		string]======================================================================================
		
//		2. 이메일 abc@naver.com 아이디를 추출할 때,
//			=> split("@")
//			=> substring(email.substring(0, email.indexOf("@")) >  substring와 indexOf를 동시에 사용할 수도 있음
		
//		4. 파일명 abc.jpg에서 확장자 jpg의 갯수를 셀때.
//			if (file.substring(lastIndexOf(".") + 1).equals("jpg")) count++;
//			=> if (file.endsWith("jpg")) count++; > endsWith( )가 훨씬 간결함 (***)
		
//		5. while문에 생각없이 true값을 가지는 loop를 넣지 말 것 (***) > 이 문제는 while(index > -1)가 훨씬 간결해짐
		
//		7. 숫자 1234 등에 세자리마다 컴마출력하기
//			=> 앞자리부터 접근하면 num.length % 3만큼을 먼저 출력
//			=> 뒷자리부터 접근하면 substring(begin, end)으로 뒤에서부터 세자리씩 자르고 beginIndex가 0이 되면 멈추기
		
//		9. replace().replace() 두번도 가능
		
//		10. 숫자 '1'~'9'를 한글 '일'~'구'로 변환할 때,
//			방법1: switch로 하나하나 변환해준다.
//			방법2: 배열[i]자리에 i를 한글로 초기화해준다. > String[] 한글 = {"","일","이",..."구"} > 한글[amount[i]-'0'] 
		
//		12. (1) "2+".split("+")는 결과가 {2}배열이 생성되지만, "+2".split("+")는 {"", 2}가 생성됨 (***) 
//				"+"가 아예 없을경우 split이 되지않음
						
//			(2) 방법1: 연산자를 for문 내부에서 charAt[i]이 숫자가 아닌부분으로 찾아냄 > 연산자가 아예 없을 경우 오류처리됨.
//				=> 방법2: 연산자가 포함되어있는지 여부를 contains("+")로 찾은 후, 연산자를 string 변수에 "\\+"형태로 저장
//				=> 방법3: 연산자가 포함되어있는지 여부를 indexof("+") > -1로 찾은후,	substring()으로 바로 피연산자 추출
	
//		class]=========================================================================================
	
//		1. StringBuilder -> 가독성이 높아짐
		
//		3. ** Math.ceil로 처리해야 함
		
//		5.	유지보수를 최대한 적게 할 수 있도록!
//			System.out.println("마카롱 10개를 만들었습니다.");
//			=> System.out.println("마카롱 " + list.length + "개를 만들었습니다.");
		
//		8. Time(int hour, int min, int second) { } > 생성자 구현코드가 없어도 초기화 됨 
	
//		collection]=====================================================================================
		
//		1.
		
//		4.
		
//		5.
		
//		file]=====================================================================================
		
//		2.	(1) 파일명에서 확장자 추출시 contain("." + extension) 보다는 endsWith("." + extension)사용하기
//			(2) 확장자 등을 입력받아 검색할 때 대소문자 구분없이!
		
//		3. 	파일 이동 전 중복된 파일이 있는지는 가상의 파일경로로 만들어진 파일객체의 exist()를 확인하면 됌 > 같은 이름이 있는지 직접 확인할 필요 없음
		
//		7. 	setA와 setB에 중복된 값이 있는지 확인하는 방법
//			if(!set.add(f.getName())) 	> setA를 만들고 SetB에 넣을 값을 그냥 setA에 add()하여 성공하는지 확인
//			=> setA.retainAll(setB); (***) 	> setA와 setB를 만들고 교집합!
		
//		8. 	폴더(자식 파일 + 자식 폴더와 자식 폴더의 파일)를 삭제할 때 폴더삭제 코드를 어디 넣는지에 따라 대상폴더까지 삭제되는지가 결정됨		
//			for (File subdir : dir.listFiles()) { if(subdir.isDirectory()) { deleteDirectory(subdir);  subdir.delete()}}  
//			=> for (File subdir : dir.listFiles()) { if(subdir.isDirectory()) { deleteDirectory(subdir);}}  dir.delete(); (***) 
		
//		9. 메인 메소드에서 ArrayList<String> a를 만든 후 메소드에 인자로 전달하면, 값형과 달리 주소값 복사가 이뤄져서 ArrayList를 return할 필요가 없음
		
//		11. (1) BufferedReader와 BufferedWriter를 동시에 사용하여 한 줄씩 읽고 바로 파일 내용을 수정하여 새로 작성할 수 있음
//			=> while((line = reader.readLine()) != null) {
//					writer.write(line.replace(word, newWord));
//					writer.newLine();
//				}
			
//			(2) new BufferedWriter(new FileWriter(filePath))에서는 file의 존재여부와 관계없이, 자동으로 새 파일이 생성됨(***)
			
//			(3) BufferedReader의 readLine()의 결과가 빈줄이면 null이 아니라 ""(빈문자열)이 반환됨. 즉, null != "" (***)
			
//		13. 전체 목록을 탐색해야 할 때(루프를 돌 때)는 HashSet보다 ArrayList가 편함
		
//		15. 동일이름의 다른 회원을 처리해야함
//		
//		17. 클래스에서 ArrayList 참조변수만 만들면 안되고 반드시 ArrayList 객체 생성을 해야 사용가능!!! (***)
		
	}
}



















